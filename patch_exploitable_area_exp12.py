import sys
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors
import json
import math
from abm.replay.replay import ExperimentReplay

########################### DOCUMENTATION ######################################
#
# What patch_exploitable_area.py does:
# When doing an experiment with different values for RADIUS_RESOURCE the script creates
# for each value a 2D heatmap plot of the exploitable area (area covered by patches)
# and a plot of the locations of the centers of the patches for testing reasons. The
# plots contain the parameter values in the respective filename and the plot title itself.
# Furthermore normalized_pixel_array.npz is created for doing quick adaptations in the plots.

#
# How to use the scripts_
# - run nb_exp12.py (define EXPERIMENT_NAME, e.g. patch_place_distr)
# - adapt nb_exp12.py by varying `num_patches`. Define at least two values, e.g. `num_patches = [1, 5]`
#   patch_exploitable_area_exp12.py fails if only one value is given!
# - adapt filepath in patch_exploitable_area_exp12.py (e.g. filepath = 'home/ABM/abm/data/simulation_data/patch_place_distr')
# - run patch_exploitable_area_exp12.py (the directory where to patch_exploitable_area.py is arbitrary)
# - a folder patch_place_distr/summary/patch_distr will be created containing the plots named after
#   the the different parameters used and the .npz-files for redoing the plots
#
################################################################################

# TODO see modifiy_pixel_array_circle()

# for loading data from /summary
filepath = 'ABM/abm/data/simulation_data/patch_place_distr_bugfix3/'
# for storing plots of patch distribution
folderpath = filepath + '/summary/patch_distr'
window_pad = 30 # hardcoded

# see "Equation of a circle" in  https://en.wikipedia.org/wiki/Circle#Equations
def modifiy_pixel_array_circle(pixel_array, m_x, m_y, radius):
    """ Modifies a 2D pixel array such that in the area of a circle with given
    position (center of the circle) and radius a one is added.

    Parameters
    ----------
    pixel_array : 2d array
    m_x : x-location of circle.
    m_y : y-location of circle.
    radius : radius of circle.

    Returns: modified pixel_array
    """
    ENV_HEIGHT, ENV_WIDTH = np.shape(pixel_array)
    # TODO Check if arena consists of pixel id = 0 until pixel id = ENV_WIDTH-1 or
    #      id = 1 until pixel id = ENV_WIDTH (and respectively for ENV_HEIGHT)
    #      => If necessary adapt range().

    left_end_circle = int(m_x - radius)
    right_end_circle = int(m_x + radius + 1)
    upper_end_circle = int(m_y - radius)
    lower_end_circle = int(m_y + radius + 1)

    # adapt _end_circle such that no pixels are placed outside arena.
    if left_end_circle < 0:
        left_end_circle = 0
    if right_end_circle > ENV_WIDTH:
        right_end_circle = ENV_WIDTH
    if upper_end_circle < 0:
        upper_end_circle = 0
    if lower_end_circle > ENV_HEIGHT:
        lower_end_circle = ENV_HEIGHT

    for x in range(left_end_circle, right_end_circle):
        for y in range(upper_end_circle, lower_end_circle):
            dx = x - m_x
            dy = y - m_y
            distance_squared = dx * dx + dy * dy

            if distance_squared <= (radius * radius):
                pixel_array[y,x] = pixel_array[y,x] + 1
    return pixel_array

def loop_params_batches_patches(folderpath, ENV_HEIGHT, ENV_WIDTH, N_RESOURCES, posx, posy, RADIUS_RESOURCE, nr_of_radii, num_batches, window_pad):
    for i in range(0,nr_of_radii):
        x_values = []
        y_values = []
        for j in range(0,num_batches):
            # x_values = np.append(x_values, posx[j,i,nr_of_radii - 1 - i,:,0][:int(N_RESOURCES[i])] - window_pad)
            # y_values = np.append(y_values, posy[j,i,nr_of_radii - 1 - i,:,0][:int(N_RESOURCES[i])] - window_pad)
            # # bug fix
            # # TODO check again: see x = np.random.randint(float, float) in sims.py. For float it rounds down so here we need to ceil
            x_values = np.append(x_values, posx[j,i,nr_of_radii - 1 - i,:,0][:int(N_RESOURCES[i])] - window_pad + int(RADIUS_RESOURCE[nr_of_radii - 1 - i]))
            y_values = np.append(y_values, posy[j,i,nr_of_radii - 1 - i,:,0][:int(N_RESOURCES[i])] - window_pad + int(RADIUS_RESOURCE[nr_of_radii - 1 - i]))

        # making sure that no drawn location is outside the arena borders
        max_x_values = np.max(x_values)
        max_y_values = np.max(y_values)
        if (max_x_values > ENV_WIDTH) | (max_y_values > ENV_HEIGHT):
            sys.exit('At least one patch location is outside the arena borders.')

        # loop through patch locations and "create" a filled CIRCLE for each location in pixel array
        pixel_array = np.zeros([ENV_HEIGHT,ENV_WIDTH])
        for k in range(0,len(x_values)):
            pixel_array = modifiy_pixel_array_circle(pixel_array, x_values[k], y_values[k], RADIUS_RESOURCE[nr_of_radii - 1 - i])
        # normalized_pixel_array = pixel_array / pixel_array.sum() # this is the probability density for num_batches initializations
        normalized_pixel_array = pixel_array / num_batches # this is the frequency a pixel is covered
        # save pixel array for adapting plots (computation of pixel array is slow)
        np.savez(folderpath +'/normalized_pixel_array_circles_R_R_{}_N_R_{}_batches_{}.npz'.format(round(RADIUS_RESOURCE[nr_of_radii - 1 - i],2),int(N_RESOURCES[i]),num_batches),normalized_pixel_array=normalized_pixel_array)
        plot_exploitable_area(normalized_pixel_array, RADIUS_RESOURCE, N_RESOURCES, num_batches, folderpath, i)

        # loop through patch locations and add + 1 for each PIXEL location in pixel array
        pixel_array = np.zeros([ENV_HEIGHT,ENV_WIDTH])
        for k in range(0,len(x_values)):
            pixel_array[int(y_values[k]),int(x_values[k])] = pixel_array[int(y_values[k]),int(x_values[k])] + 1
        # normalized_pixel_array = pixel_array / pixel_array.sum() # this is the probability density for num_batches initializations
        normalized_pixel_array = pixel_array / num_batches # this is the frequency a pixel is covered
        # save pixel array for adapting plots (computation of pixel array is slow)
        np.savez(folderpath +'/normalized_pixel_array_locations_R_R_{}_N_R_{}_batches_{}.npz'.format(round(RADIUS_RESOURCE[nr_of_radii - 1 - i],2),int(N_RESOURCES[i]),num_batches),normalized_pixel_array=normalized_pixel_array)
        plot_locations(normalized_pixel_array, RADIUS_RESOURCE, N_RESOURCES, num_batches, folderpath, i)
    return

def plot_exploitable_area(pixel_array, RADIUS_RESOURCE, N_RESOURCES, num_batches, folderpath, i):
    plt.figure()
    plt.xlabel('location x')
    plt.ylabel('location y')
    plt.title('ar R_R={} N_R={} batches={}'.format(round(RADIUS_RESOURCE[nr_of_radii - 1 - i],2),int(N_RESOURCES[i]),num_batches))
    color_map = plt.imshow(pixel_array)
    color_map.set_cmap("viridis")
    plt.colorbar(label='Frequency')
    # plt.colorbar(label='Probability density')
    plt.tight_layout()
    plt.savefig(folderpath +'/exploitable_area_R_R_{}_N_R_{}_batches_{}.png'.format(round(RADIUS_RESOURCE[nr_of_radii - 1 - i],2),int(N_RESOURCES[i]),num_batches))
    return

def plot_locations(pixel_array, RADIUS_RESOURCE, N_RESOURCES, num_batches, folderpath, i):
    plt.figure()
    plt.xlabel('location x')
    plt.ylabel('location y')
    plt.title('loc R_R={} N_R={} batches={}'.format(round(RADIUS_RESOURCE[nr_of_radii - 1 - i],2),int(N_RESOURCES[i]),num_batches))
    color_map = plt.imshow(pixel_array)
    color_map.set_cmap("viridis")
    plt.colorbar(label='Frequency')
    # plt.colorbar(label='Probability density')
    plt.tight_layout()
    plt.savefig(folderpath +'/locations_R_R_{}_N_R_{}_batches_{}.png'.format(round(RADIUS_RESOURCE[nr_of_radii - 1 - i],2),int(N_RESOURCES[i]),num_batches))
    return

# load data from /summary
data = ExperimentReplay(filepath, undersample=1)

# create file for storing plots
if os.path.exists(folderpath) == False:
    os.mkdir(folderpath)

# read out parameters from .json-files for printing/showing them in plots and filesnames
# fixed_env
# abm/data/simulation_data/experiment_name/summary/fixed_env.json
with open(filepath + '/summary/fixed_env.json', 'r') as k:
     fixed_env =  json.loads(k.read())

ENV_WIDTH = fixed_env['ENV_WIDTH']
ENV_HEIGHT = fixed_env['ENV_HEIGHT']

# tuned_env
# abm/data/simulation_data/experiment_name/summary/tuned_env.json
with open(filepath + '/summary/tuned_env.json', 'r') as k:
     tuned_env =  json.loads(k.read())

RADIUS_RESOURCE = tuned_env['RADIUS_RESOURCE'] # different radii used in experiment
N_RESOURCES = tuned_env['N_RESOURCES']
posx = data.res_pos_x_z
posy = data.res_pos_y_z
num_batches, nr_of_radii, length_num_patches, max_N_RESOURCES , T = posx.shape

loop_params_batches_patches(folderpath, ENV_HEIGHT, ENV_WIDTH, N_RESOURCES, posx, posy, RADIUS_RESOURCE, nr_of_radii, num_batches, window_pad)

import sys
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors
import json

########################### DOCUMENTATION ######################################
#
# What patch_exploitable_area.py does:
# When doing an experiment with different values for RADIUS_RESOURCE the script creates
# for each value a 2D heatmap plot of the exploitable area (area covered by patche) containing
# the parameter values in the respective filename and the plot itself.
# Furthermore normalized_pixel_array.npz is created for doing adaptations in the plots
# as the computation of the pixel array is comutationally costly.
#
# How to use the scripts_
# - run exp11.py (define EXPERIMENT_NAME, e.g. patch_place_distr)
# - run load_data_test.py
# - adapt filepath in patch_exploitable_area.py (e.g. filepath = 'home/ABM/abm/data/simulation_data/patch_place_distr')
# - run patch_exploitable_area.py (the directory where to patch_exploitable_area.py is arbitrary)
# - a folder patch_place_distr/summary/patch_distr will be created containing the plots named after
#   the the different parameters used.
#
################################################################################

# TODO see modifiy_pixel_array_circle()
# TODO organize data in dataframe

# for loading data from /summary
filepath = 'ABM/abm/data/simulation_data/patch_place_distr/'
# for storing plots of patch distribution
folderpath = filepath + '/summary/patch_distr'
window_pad = 30 # hardcoded


# see "Equation of a circle" in  https://en.wikipedia.org/wiki/Circle#Equations
def modifiy_pixel_array_circle(pixel_array, m_x, m_y, radius):
    """ Modifies a 2D pixel array such that in the area of a circle with given
    position (center of the circle) and radius a one is added.

    Parameters
    ----------
    pixel_array : 2d array
    m_x : x-location of circle.
    m_y : y-location of circle.
    radius : radius of circle.

    Returns: modified pixel_array
    """
    ENV_HEIGHT, ENV_WIDTH = np.shape(pixel_array)
    # TODO Check if arena consists of pixel id = 0 until pixel id = ENV_WIDTH-1 or
    #      id = 1 until pixel id = ENV_WIDTH (and respectively for ENV_HEIGHT)
    #      => If necessary adapt range().

    left_end_circle = int(m_x - radius)
    right_end_circle = int(m_x + radius + 1)
    upper_end_circle = int(m_y - radius)
    lower_end_circle = int(m_y + radius + 1)

    # adapt _end_circle such that no pixels are placed outside arena.
    if left_end_circle < 0:
        left_end_circle = 0
    if right_end_circle > ENV_WIDTH:
        right_end_circle = ENV_WIDTH
    if upper_end_circle < 0:
        upper_end_circle = 0
    if lower_end_circle > ENV_HEIGHT:
        lower_end_circle = ENV_HEIGHT

    for x in range(left_end_circle, right_end_circle):
        for y in range(upper_end_circle, lower_end_circle):
            dx = x - m_x
            dy = y - m_y
            distance_squared = dx * dx + dy * dy

            if distance_squared <= (radius * radius):
                pixel_array[y,x] = pixel_array[y,x] + 1
    return pixel_array

def loop_params_batches_patches(folderpath, ENV_HEIGHT, ENV_WIDTH, N_RESOURCES, posx, posy, RADIUS_RESOURCE, nr_of_radii, num_batches, window_pad):
    for i in range(0,nr_of_radii):
        x_values = []
        y_values = []
        for j in range(0,num_batches):
            x_values = np.append(x_values, posx[j,i,:,0] - window_pad)
            y_values = np.append(y_values, posy[j,i,:,0] - window_pad)

        # making sure that no drawn location is outside the arena borders
        max_x_values = np.max(x_values)
        max_y_values = np.max(y_values)
        if (max_x_values > ENV_WIDTH) | (max_y_values > ENV_HEIGHT):
            sys.exit('At least one patch location is outside the arena borders.')

        # loop through patch locations and "create" a filled circle for each location in pixel array
        pixel_array = np.zeros([ENV_HEIGHT,ENV_WIDTH])
        for k in range(0,len(x_values)):
            pixel_array = modifiy_pixel_array_circle(pixel_array, x_values[k], y_values[k], RADIUS_RESOURCE[i])
        # normalized_pixel_array = pixel_array / pixel_array.sum() # this is the probability density for num_batches initializations
        normalized_pixel_array = pixel_array / num_batches # this is the frequency a pixel is covered
        # save pixel array for adapting plots (computation of pixel array is slow)
        np.savez(folderpath +'/normalized_pixel_array_R_R_{}_N_R_{}_batches_{}.npz'.format(round(RADIUS_RESOURCE[i],2),N_RESOURCES,num_batches),normalized_pixel_array=normalized_pixel_array)
        plot_exploitable_area(normalized_pixel_array, RADIUS_RESOURCE, N_RESOURCES, num_batches, folderpath, i)
    return

def plot_exploitable_area(pixel_array, RADIUS_RESOURCE, N_RESOURCES, num_batches, folderpath, i):
    plt.figure()
    plt.xlabel('location x')
    plt.ylabel('location y')
    plt.title('R_R={} N_R={} batches={}'.format(round(RADIUS_RESOURCE[i],2),N_RESOURCES,num_batches))
    color_map = plt.imshow(pixel_array)
    color_map.set_cmap("viridis")
    plt.colorbar(label='Frequency')
    # plt.colorbar(label='Probability density')
    plt.tight_layout()
    plt.savefig(folderpath +'/exploitable_area_R_R_{}_N_R_{}_batches_{}.pdf'.format(round(RADIUS_RESOURCE[i],2),N_RESOURCES,num_batches))
    return


# load data from /summary
data = np.load(filepath + '/summary/resource_summary.npz')
# create file for storing plots
if os.path.exists(folderpath) == False:
    os.mkdir(folderpath)

# read out parameters from .json-files for printing/showing them in plots and filesnames
# fixed_env
# abm/data/simulation_data/experiment_name/summary/fixed_env.json
with open(filepath + '/summary/fixed_env.json', 'r') as k:
     fixed_env =  json.loads(k.read())

ENV_WIDTH = fixed_env['ENV_WIDTH']
ENV_HEIGHT = fixed_env['ENV_HEIGHT']

# tuned_env
# abm/data/simulation_data/experiment_name/summary/tuned_env.json
with open(filepath + '/summary/tuned_env.json', 'r') as k:
     tuned_env =  json.loads(k.read())

RADIUS_RESOURCE = tuned_env['RADIUS_RESOURCE'] # different radii used in experiment

posx = data["posx"]
posy = data["posy"]

num_batches, nr_of_radii, N_RESOURCES , T = posx.shape

loop_params_batches_patches(folderpath, ENV_HEIGHT, ENV_WIDTH, N_RESOURCES, posx, posy, RADIUS_RESOURCE, nr_of_radii, num_batches, window_pad)
